 public static LinkedList<String> viterbi(HashMap<String, HashMap<String, Double>> transitionMap,
            HashMap<String, HashMap<String, Double>> emissionMap, String testSentence) {

        //penalty for a word not existing
        Double U = -100.0;

        try {

            BufferedReader sentenceInput = new BufferedReader(new FileReader(testSentence));

            String sentenceString = null;

            while ((sentenceString = sentenceInput.readLine()) != null) {

                HashMap<Integer, HashMap<String, HashMap<String, Double>>>
                        backtraceMap = new HashMap<Integer, HashMap<String, HashMap<String, Double>>>();

                sentenceString = sentenceString.toLowerCase();
                String[] splitSentence = sentenceString.split(" ");

                double score;

                HashMap<String, HashMap<String, Double>> nextMap = new HashMap<>();

                for (String nextKey : transitionMap.get("#").keySet()) {
                    if (!emissionMap.get(nextKey).containsKey(splitSentence[0])) {
                        score = transitionMap.get("#").get(nextKey) + U;
                    } else {
                        score = transitionMap.get("#").get(nextKey) + emissionMap.get(nextKey).get(splitSentence[0]);
                    }

                    HashMap<String, Double> currentMap = new HashMap<>();
                    currentMap.put("#", score);

                    nextMap.put(nextKey, currentMap);

                    backtraceMap.put(0, nextMap);
                }

                for (int i = 1; i < splitSentence.length; i++) {
                    nextMap = new HashMap<>();
                    for (String currentKey : backtraceMap.get(i - 1).keySet()) {
                        if (!transitionMap.containsKey(currentKey)) {
                            continue;
                        } else {
                            for (String nextKey : transitionMap.get(currentKey).keySet()) {
                                Double previousScore = 0.0;
                                for (String previousKey : backtraceMap.get(i - 1).get(currentKey).keySet()) {
                                    previousScore = backtraceMap.get(i - 1).get(currentKey).get(previousKey);
                                }
                                if (!emissionMap.get(nextKey).containsKey(splitSentence[i])) {
                                    score = previousScore + transitionMap.get(currentKey).get(nextKey) + U;
                                } else {
                                    score = previousScore + transitionMap.get(currentKey).get(nextKey)
                                            + emissionMap.get(nextKey).get(splitSentence[i]);
                                }


                                HashMap<String, Double> currentMap;

                                if (!backtraceMap.containsKey(i) || !backtraceMap.get(i).containsKey(nextKey)) {
                                    currentMap = new HashMap<>();
                                    currentMap.put(currentKey, score);
                                } else {
                                    currentMap = backtraceMap.get(i).get(nextKey);
                                    for (String existingNextKey : currentMap.keySet()) {
                                        if (currentMap.get(existingNextKey) < score) {
                                            currentMap.remove(existingNextKey);
                                            currentMap.put(currentKey, score);
                                        }
                                    }
                                }

                                nextMap.put(nextKey, currentMap);

                                backtraceMap.put(i, nextMap);


                            }
                        }
                    }

                }

                double maxScore = Double.NaN;
                String finalTag = null;

                for (String nextKey : backtraceMap.get(backtraceMap.size() - 1).keySet()) {
                    for (String currentKey : backtraceMap.get(backtraceMap.size() - 1).get(nextKey).keySet()) {
                        if (Double.isNaN(maxScore)) {
                            maxScore = backtraceMap.get(backtraceMap.size() - 1).get(nextKey).get(currentKey);
                            finalTag = currentKey;
                        }
                        if (backtraceMap.get(backtraceMap.size() - 1).get(nextKey).get(currentKey) > maxScore) {
                            maxScore = backtraceMap.get(backtraceMap.size() - 1).get(nextKey).get(currentKey);
                            finalTag = currentKey;
                        }
                    }
                }

                LinkedList<String> tagList = new LinkedList<>();
                tagList.add(finalTag);

                String tag = finalTag;

                for (int i = backtraceMap.size() - 2; i > 0; i--) {
                    for (String tempTag : backtraceMap.get(i).get(tag).keySet()) {
                        tagList.add(0, tempTag);
                        tag = tempTag;
                    }
                }

                completedTagLineList.add(tagList);
            }


            return completedTagLineList;


        } catch (FileNotFoundException e) {
            System.out.println("File not Found");
        } catch (Exception e) {
            System.out.println("Unknown Exception");
        } finally {
            //if things fail, a null version should be returned
            return completedTagLineList;
        }
    }